#!/bin/bash

# Install everything, including dotfiles, Vundle, brew, and prefs.
#
# Check out this repository into a directory called "dev". Running it will:
#
#   * Complete the check-out if it forgot to perform a recursive check-out.
#   * Add the following links to my home directory, or update them if they
#     already exist:
#       * .bash_profile
#       * .bashrc
#       * .gitconfig
#       * .inputrc
#       * .vim
#       * .vimrc
#       * bin
#       * dev
#       * dotfiles
#   * Create a "brew" directory next to it and put homebrew into it, or
#     update it if it already exists.
#   * Invoke my private installation script
#   * Update vim with bundles defined in .vimrc
#
# Before running, I may need to get the key used for git-crypt. Point to it
# with the --key option.

HERE="$(dirname "$0")"
REALPATH="${HERE}/bin/realpath"
HERE="$("${REALPATH}" "${HERE}")"
LNS="${HERE}/bin/lns"

KEY="" # git-crypt key

while [[ "${1:+x}" ]]
do
    case "$1" in
        --key)      KEY="$2"; shift 2;;
        *)          echo "### Unknown parameter: $p"; exit 1;;
    esac
done

# Make sure we are in a dev/dotfiles directory. We want this arrangement so
# that we can check out `brew` into dev/brew.

DEV_PATH="$(dirname "${HERE}")"
DEV_NAME="$(basename "${DEV_PATH}")"
if [[ "${DEV_NAME}" != "dev" ]]
then
    echo "### dotfiles must be in dev parent directory"
    exit 1
fi

# If I forgot to recursively checkout dotfiles, do that now. Otherwise, update
# the submodules.

if [[ ! -d "${HERE}/vim/bundle/Vundle.vim" ]]
then
    echo "*** Installing submodules"
    git -C "${HERE}" submodule update --init --recursive
else
    echo "*** Updating submodules"
    git -C "${HERE}" submodule foreach git pull origin master
fi

# Make sure that brew's home has been created. If not, bashrc (called next)
# will not define some needed environment variables.

BREW_PATH="${DEV_PATH}/brew"
if [[ ! -d "${BREW_PATH}" ]]
then
    echo "*** Creating brew directory"
    mkdir "${BREW_PATH}"
fi

# Get some handy functions defined.

source "${HERE}/bashrc"

# Create or update links in my home directory to handy things elsewhere.

function create_link_in_home()
{
    local file="$1"
    local link="$2"

    [[ -z "${link}" ]] && link="$(basename "${file}")"

    file="$("${REALPATH}" "${file}")"
    link="${HOME}/${link}"

    if [[ -e "${link}" && ! -L "${link}" ]]
    then
        echo "### File ${link} exists and is not a link. Please move it aside."
        return
    fi

    rm -f "${link}"
    "$LNS" "${file}" "${link}"
}

echo "*** Creating/updating home directory links"

create_link_in_home "${HERE}/bash_profile"  .bash_profile
create_link_in_home "${HERE}/bashrc"        .bashrc
create_link_in_home "${HERE}/gitconfig"     .gitconfig
create_link_in_home "${HERE}/inputrc"       .inputrc
create_link_in_home "${HERE}/vim"           .vim
create_link_in_home "${HERE}/vimrc"         .vimrc

create_link_in_home "${HERE}"
create_link_in_home "${HERE}/bin"
create_link_in_home "${DEV_PATH}"

# Run through bashrc again. It might now define some variables that it couldn't
# before the above links were created.

source "${HERE}/bashrc"

# Install Brew now. We need to do this before invoking install.private since
# that file might be encrypted and we need git-crypt from brew in order to
# decrypt it.

maybe_source "${HERE}/install.brew"

function is_decrypted()
{
    [[ "$(git -C "${HERE}" config --get filter.git-crypt.required)" == "true" ]]
}

if ! is_decrypted
then
    if [[ -n "${KEY}" ]]
    then
        git -C "${HERE}" crypt unlock "${KEY}"
    else
        echo "### WARNING: git repository is encrypted. Specify a key with --key to decrypt it."
    fi
fi

if is_decrypted
then
    maybe_source "${HERE}/install.private"
fi

# Install/update vim bundles. Let's do this last so that the operation can be
# done in the full context of environment variables and tools.

echo "*** Installing/updating vim bundles"
vim +PluginInstall +qall &> /dev/null
